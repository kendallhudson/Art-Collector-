{"version":3,"sources":["components/Title.js","api/index.js","components/Search.js","components/Preview.js","components/Feature.js","components/Loading.js","index.js"],"names":["Title","id","BASE_URL","KEY","fetchQueryResultsFromTermAndValue","term","value","a","fetch","encodeURI","split","join","response","json","data","fetchQueryResultsFromURL","url","fetchQueryResults","century","classification","queryString","fetchAllCenturies","localStorage","getItem","JSON","parse","records","setItem","stringify","fetchAllClassifications","Search","props","setIsLoading","setSearchResults","useState","centuryList","setCenturyList","classificationList","setClassificationList","setQueryString","setCentury","setClassification","console","log","useEffect","Promise","all","then","error","onSubmit","event","preventDefault","results","htmlFor","type","placeholder","onChange","target","className","length","name","map","key","Preview","setFeaturedResult","info","searchResults","fetchPage","pageUrl","disabled","undefined","prev","onClick","next","record","index","primaryimageurl","src","alt","description","title","Searchable","searchTerm","searchValue","href","Feature","featuredResult","dated","style","culture","technique","medium","people","person","displayname","dimensions","department","division","contact","creditline","images","image","baseimageurl","Loading","App","isLoading","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.6b661b27.chunk.js","sourcesContent":["import React from 'react';\n\n/**\n * Create/export a component called Title which uses this static HTML as the template:\n * \n * <div id=\"title\">\n *   <h1>\n *     The Art Collector\n *   </h1>\n *   <h5>\n *     Search the Harvard Art Museums' Private Collections\n *   </h5>\n * </div>\n */\n const Title = () => {\n    return (\n    <div id=\"title\">\n         <h1>The Art Collector</h1>\n         <h5>Search the Harvard Art Museums' Private Collections</h5>\n    </div>\n    )  \n}\n\nexport default Title; ","/**\n * This file features and exports all of your calls to the API\n * \n * You need to replace YOUR_API_KEY in the string associated with KEY with your actual API key\n */\nexport const BASE_URL = 'https://api.harvardartmuseums.org';\nexport const KEY = 'apikey=1e364458-ab16-4164-9c9e-a089969d6415';\n\n/**\n * This will make a call to the API for a single term and value (e.g. \"person\", and \"unknown\"), and return the result\n */\nexport async function fetchQueryResultsFromTermAndValue(term, value) {\n  try {\n    const response = await fetch(`${ BASE_URL }/object?${ KEY }&${ term }=${ encodeURI(value.split('-').join('|')) }`);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This will make a call to the API for a preformed url (useful for previous and next buttons), and return the result\n */\nexport async function fetchQueryResultsFromURL(url) {\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * Requires an object { century: '', classification: '', queryString: '' } to be passed in as an argument\n * \n * Then makes a call to the API, and returns the first page of results\n */\nexport async function fetchQueryResults({\n  century,\n  classification,\n  queryString,\n}) {\n  const url = `${ BASE_URL }/object?${ KEY }&classification=${ classification }&century=${ \n    century }&keyword=${ queryString }`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are centuries stored in localStorage, or fetches them from the API and stores them in localStorage if not\n */\nexport async function fetchAllCenturies() {\n  if (localStorage.getItem('centuries')) {\n    return JSON.parse(localStorage.getItem('centuries'));\n  }\n\n  const url = `${ BASE_URL }/century?${ KEY }&size=100&sort=temporalorder`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('centuries', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are classifications stored in localStorage, or fetches them from the API and stores them in localStorage if not \n */\nexport async function fetchAllClassifications() {\n  if (localStorage.getItem('classifications')) {\n    return JSON.parse(localStorage.getItem('classifications'));\n  }\n\n  const url = `${ BASE_URL }/classification?${ KEY }&size=100&sort=name`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('classifications', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}","import React, { useEffect, useState } from 'react';\n/**\n * Don't touch these imports!\n */\nimport {\n    fetchAllCenturies,\n    fetchAllClassifications,\n    fetchQueryResults\n} from '../api';\nconst Search = (props) => {\n    // Make sure to destructure setIsLoading and setSearchResults from the props\n    const { setIsLoading } = props;\n    const { setSearchResults } = props;\n    /**\n     * We are at the Search component, a child of app. This has a form, so we need to use useState for\n     * our controlled inputs:\n     *\n     * centuryList, setCenturyList (default should be an empty array, [])\n     * classificationList, setClassificationList (default should be an empty array, [])\n     * queryString, setQueryString (default should be an empty string, '')\n     * century, setCentury (default should be the string 'any')\n     * classification, setClassification (default should be the string 'any')\n     */\n    const [centuryList, setCenturyList] = useState([]);\n    const [classificationList, setClassificationList] = useState([]);\n    const [queryString, setQueryString] = useState('');\n    const [century, setCentury] = useState('any');\n    const [classification, setClassification] = useState('any');\n    console.log(props);\n    const handleQueryString = (event) => {\n        setQueryString(event.target.value);\n    }\n    const handleClassification = (event) => {\n        setClassification(event.target.value);\n    }\n    const handleCentury = (event) => {\n        setCentury(event.target.value);\n    }\n    /**\n     * Inside of useEffect, use Promise.all([]) with fetchAllCenturies and fetchAllClassifications\n     *\n     * In the .then() callback pass the returned lists to setCenturyList and setClassificationList\n     *\n     * Make sure to console.error on caught errors from the API methods.\n     */\n    useEffect(() => {\n        const PromiseArr = Promise.all([fetchAllCenturies(), fetchAllClassifications()])\n        PromiseArr.then((value) => {\n          try {\n            console.log(value);\n            setCenturyList(value[0]);\n            setClassificationList(value[1]);\n          } catch (error) {\n            console.error(error);\n          }\n            \n        })\n    }, []);\n    /**\n     * This is a form element, so we need to bind an onSubmit handler to it which:\n     *\n     * calls event.preventDefault()\n     * calls setIsLoading, set it to true\n     *\n     * then, in a try/catch/finally block:\n     *\n     * try to:\n     * - get the results from fetchQueryResults({ century, classification, queryString })\n     * - pass them to setSearchResults\n     *\n     * catch: error to console.error\n     *\n     * finally: call setIsLoading, set it to false\n     */\n    return <form id=\"search\" onSubmit={async (event) => {\n        event.preventDefault();\n        setIsLoading(true);\n        // write code here\n        try {\n          const results = await fetchQueryResults({ century, classification, queryString });\n          setSearchResults(results);\n        } catch (error) {\n          console.error(error);\n        }\n        // try {\n        //     setSearchResults(fetchQueryResults({ century, classification, queryString })\n        // } catch (err) {\n        //     console.log(`The error is: ${err}`);\n        // }\n        setIsLoading(false);\n    }}>\n        <fieldset>\n            <label htmlFor=\"keywords\">Query</label>\n            <input\n                id=\"keywords\"\n                type=\"text\"\n                placeholder=\"enter keywords...\"\n                value={queryString}\n                onChange={handleQueryString} />\n        </fieldset>\n        <fieldset>\n            <label htmlFor=\"select-classification\">Classification <span className=\"classification-count\">({classificationList.length})</span></label>\n            <select\n                name=\"classification\"\n                id=\"select-classification\"\n                value={classification}\n                onChange={handleClassification}>\n                <option value=\"any\">Any</option>\n                {classificationList.map((classification) => {\n                  return <option key={classification.id}>{classification.name}</option>\n              })}\n            </select>\n        </fieldset>\n        <fieldset>\n            <label htmlFor=\"select-century\">Century <span className=\"century-count\">({centuryList.length})</span></label>\n            <select\n                name=\"century\"\n                id=\"select-century\"\n                value={century}\n                onChange={handleCentury}>\n                <option value=\"any\">Any</option>\n                {centuryList.map((century) => {\n                  return <option key={century.id}>{century.name}</option>\n              })}\n            </select>\n        </fieldset>\n        <button>SEARCH</button>\n    </form>\n}\nexport default Search;","import React from 'react';\n// import KEY from './components/index.js' -- don't have to do this, may not be correct\n\n/**\n * We need to import fetchQueryResultsFromURL since we will sometimes have urls in info.prev and info.next\n * which are query urls.\n */\nimport { fetchQueryResultsFromURL } from '../api';\n\nconst Preview = (props) => {\n\n  const { setIsLoading } = props;\n  const { setSearchResults } = props;\n  const { setFeaturedResult } = props;\n  const { info } = props.searchResults;\n  const { records } = props.searchResults;\n\n  /**\n   * Destructure setSearchResults, setFeaturedResult, and setIsLoading from props\n   * and also destructure info and records from props.searchResults\n   * \n   * You need info, records, setSearchResults, setFeaturedResult, and setIsLoading as available constants\n   */\n\n\n  /**\n   * Don't touch this function, it's good to go.\n   * \n   * It has to be defined inside the Preview component to have access to setIsLoading, setSearchResults, etc...\n   */\n  async function fetchPage(pageUrl) {\n    setIsLoading(true);\n\n    try {\n      const results = await fetchQueryResultsFromURL(pageUrl);\n      setSearchResults(results);\n    } catch (error) {\n      console.error(error);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  return <aside id=\"preview\">\n    <header className=\"pagination\">\n      {/* This button should be disabled if nothing is set in info.prev, and should call fetchPage with info.prev when clicked */}\n\n    {/* <---------INFINITE LOOP BUTTONS------------> */}\n\n      <button \n        disabled={info?.prev === undefined} \n        className=\"previous\"\n        onClick={() => fetchPage(info.prev)}>Previous</button>\n      {/* This button should be disabled if nothing is set in info.next, and should call fetchPage with info.next when clicked */}\n     <button\n        disabled={info?.next === undefined}\n        className=\"next\"\n        onClick={() => fetchPage(info.next)}>Next</button>\n\n      {/* <---------INFINITE LOOP BUTTONS------------> */}\n    </header>\n    <section className=\"results\">\n      {\n        records.map((record, index) => {\n          return <div\n            key={index}\n            className=\"object-preview\"\n            onClick={(event) => {\n              event.preventDefault()\n              setFeaturedResult(record)\n            }}> \n            {record.primaryimageurl && <img src={ record.primaryimageurl } alt={ record.description } />} {record.title && <h3>{ record.title }</h3>}\n          </div> \n        }\n        /* Here we should map over the records, and render something like this for each one:\n          <div  \n            key={ index }\n            className=\"object-preview\"\n            onClick={(event) => { \n              // prevent the default\n              // set the featured result to be this record, using setFeaturedResult\n            }}>\n            { \n              // if the record.primaryimageurl exists, show this: <img src={ record.primaryimageurl } alt={ record.description } />, otherwise show nothing \n            }\n            {\n              // if the record.title exists, add this: <h3>{ record.title }</h3>, otherwise show this: <h3>MISSING INFO</h3>\n            }\n          </div>\n        */\n      )}\n    </section>\n  </aside>\n}\n\nexport default Preview;","// import React, { Fragment } from 'react';\n\n// // Don't touch this import\n// import { fetchQueryResultsFromTermAndValue } from '../api';\n\n// /**\n//  * We need a new component called Searchable which:\n//  * \n//  * Has a template like this:\n//  * \n//  * <span className=\"content\">\n//  *  <a href=\"#\" onClick={async (event) => {}}>SOME SEARCH TERM</a>\n//  * </span>\n//  *\n//  * You'll need to read searchTerm, searchValue, setIsLoading, and setSearchResults off of the props.\n//  * \n//  * When someone clicks the anchor tag, you should:\n//  * \n//  * - preventDefault on the event\n//  * - call setIsLoading, set it to true\n//  * \n//  * Then start a try/catch/finally block:\n//  * \n//  * try:\n//  *  - await the result of fetchQueryResultsFromTermAndValue, passing in searchTerm and searchValue\n//  *  - send the result to setSearchResults (which will update the Preview component)\n//  * catch: \n//  *  - console.error the error\n//  * finally:\n//  *  - call setIsLoading, set it to false\n//  */\n\n// const Searchable = ({ searchTerm, setIsLoading, setSearchResults, searchValue } ) => {\n    \n//     return <Fragment>\n//     <span className='title'>\n//         {searchTerm}\n//     </span>\n\n//     <span className=\"content\">\n//       <a href=\"#\" onClick={async (event) => {\n//           event.preventDefault();\n//           setIsLoading(true);\n//           try{\n//                 const response = await fetchQueryResultsFromTermAndValue(searchTerm, searchValue);\n//                 setSearchResults(response);\n//           } catch (error) {\n//                 console.error(error);\n//           } finally {\n//                 setIsLoading(false);\n//           }\n//           }}>{searchValue}</a>\n//     </span>\n//     </Fragment>\n// }\n// /**\n//  * We need a new component called Feature which looks like this when no featuredResult is passed in as a prop:\n//  * \n//  * <main id=\"feature\"></main>\n//  * \n//  * And like this when one is:\n//  * \n//  * <main id=\"feature\">\n//  *   <div className=\"object-feature\">\n//  *     <header>\n//  *       <h3>OBJECT TITLE</h3>\n//  *       <h4>WHEN IT IS DATED</h4>\n//  *     </header>\n//  *     <section className=\"facts\">\n//  *       <span className=\"title\">FACT NAME</span>\n//  *       <span className=\"content\">FACT VALUE</span>\n//  *       <span className=\"title\">NEXT FACT NAME</span>\n//  *       <span className=\"content\">NEXT FACT VALUE</span>\n//  *     </section>\n//  *     <section className=\"photos\">\n//  *       <img src=IMAGE_URL alt=SOMETHING_WORTHWHILE />\n//  *     </section>\n//  *   </div>\n//  * </main>\n//  * \n//  * The different facts look like this: title, dated, images, primaryimageurl, description, culture, style, \n//  * technique, medium, dimensions, people, department, division, contact, creditline\n//  * \n//  * The <Searchable /> ones are: culture, technique, medium (first toLowerCase it), and person.displayname (one for each PEOPLE)\n//  * \n//  * NOTE: people and images are likely to be arrays, and will need to be mapped over if they exist\n//  * \n//  * This component should be exported as default.\n//  */\n// const Feature = ({featuredResult, setIsLoading, setSearchResults}) => {\n//     if (featuredResult) {\n//         return <main id=\"feature\">\n//     <div className=\"object-feature\">\n//       <header>\n//         <h3>{featuredResult.title}</h3>\n//         <h4>{featuredResult.dated}</h4>\n//       </header>\n//       <section className=\"facts\">\n//         {description ? <Fragment>\n//            <span className=\"title\">Description</span>\n//            <span className=\"content\">{featuredResult.description}</span>\n//         </Fragment> : null}\n     \n//         {culture ? <Searchable searchValue = {featuredResult.culture} setSearchResults={setSearchResults} setIsLoading={setIsLoading} searchTerm={\"Culture\"} /> : null} \n//         <Searchable searchValue = {featuredResult.technique} setSearchResults={setSearchResults} setIsLoading={setIsLoading} searchTerm={\"Technique\"} />\n//         <Searchable searchValue = {featuredResult.medium.toLowerCase()} setSearchResults={setSearchResults} setIsLoading={setIsLoading} searchTerm={\"Medium\"} />\n        \n//         {featuredResult.people.map((person) => {\n//             return (<Searchable searchValue = {person.displayname} setSearchResults={setSearchResults} setIsLoading={setIsLoading} searchTerm={\"People\"} />)\n//         })}\n\n//         <Fragment>\n//             <span className=\"title\">Style</span>\n//             <span className=\"content\">{featuredResult.style}</span>\n//         </Fragment>\n//         <Fragment>\n//             <span className=\"title\">Technique</span>\n//             <span className=\"content\">{featuredResult.technique}</span>\n//         </Fragment>\n//         <Fragment>\n//             <span className=\"title\">NEXT FACT NAME</span>\n//             <span className=\"content\">NEXT FACT VALUE</span>\n//         </Fragment>\n//       </section>\n//       <section className=\"photos\">\n//         {/* <img src=IMAGE_URL alt=SOMETHING_WORTHWHILE /> */}\n//       </section>\n//     </div>\n//   </main>\n//     } else {\n//         return <main></main>\n//     }\n    \n// }\n\n// export default Feature;\n\nimport React, { Fragment } from 'react';\n// Don't touch this import\nimport { fetchQueryResultsFromTermAndValue } from '../api';\n/**\n * We need a new component called Searchable which:\n *\n * Has a template like this:\n *\n * <span className=\"content\">\n *  <a href=\"#\" onClick={async (event) => {}}>SOME SEARCH TERM</a>\n * </span>\n *\n * You'll need to read searchTerm, searchValue, setIsLoading, and setSearchResults off of the props.\n *\n * When someone clicks the anchor tag, you should:\n *\n * - preventDefault on the event\n * - call setIsLoading, set it to true\n *\n * Then start a try/catch/finally block:\n *\n * try:\n *  - await the result of fetchQueryResultsFromTermAndValue, passing in searchTerm and searchValue\n *  - send the result to setSearchResults (which will update the Preview component)\n * catch:\n *  - console.error the error\n * finally:\n *  - call setIsLoading, set it to false\n */\nconst Searchable = ({ searchTerm, setIsLoading, setSearchResults, searchValue }) => {\n    return <Fragment>\n        <span className='title'>\n            {searchTerm}\n        </span>\n        <span className=\"content\">\n            <a href=\"/#\" onClick={async (event) => {\n                event.preventDefault();\n                setIsLoading(true);\n                try {\n                    const response = await fetchQueryResultsFromTermAndValue(searchTerm, searchValue);\n                    setSearchResults(response);\n                } catch (error) {\n                    console.error(error);\n                } finally {\n                    setIsLoading(false);\n                }\n            }}>{searchValue}</a>\n        </span>\n    </Fragment>\n}\n/**\n * We need a new component called Feature which looks like this when no featuredResult is passed in as a prop:\n *\n * <main id=\"feature\"></main>\n *\n * And like this when one is:\n *\n * <main id=\"feature\">\n *   <div className=\"object-feature\">\n *     <header>\n *       <h3>OBJECT TITLE</h3>\n *       <h4>WHEN IT IS DATED</h4>\n *     </header>\n *     <section className=\"facts\">\n *       <span className=\"title\">FACT NAME</span>\n *       <span className=\"content\">FACT VALUE</span>\n *       <span className=\"title\">NEXT FACT NAME</span>\n *       <span className=\"content\">NEXT FACT VALUE</span>\n *     </section>\n *     <section className=\"photos\">\n *       <img src=IMAGE_URL alt=SOMETHING_WORTHWHILE />\n *     </section>\n *   </div>\n * </main>\n *\n * The different facts look like this: title, dated, images, primaryimageurl, description, culture, style,\n * technique, medium, dimensions, people, department, division, contact, creditline\n *\n * The <Searchable /> ones are: culture, technique, medium (first toLowerCase it), and person.displayname (one for each PEOPLE)\n *\n * NOTE: people and images are likely to be arrays, and will need to be mapped over if they exist\n *\n * This component should be exported as default.\n */\nconst Feature = ({ featuredResult, setIsLoading, setSearchResults }) => {\n    if (featuredResult) {\n        return <main id=\"feature\">\n            <div className=\"object-feature\">\n                <header>\n                    <h3>{featuredResult.title}</h3>\n                    <h4>{featuredResult.dated}</h4>\n                </header>\n                <section className=\"facts\">\n                    <Fragment>\n                        <span className=\"title\">Description</span>\n                        <span className=\"content\">{featuredResult.description}</span>\n                    </Fragment>\n                    <Fragment>\n                        <span className=\"title\">Style</span>\n                        <span className=\"content\">{featuredResult.style}</span>\n                    </Fragment>\n                    <Searchable searchValue={featuredResult.culture} setSearchResults={setSearchResults} setIsLoading={setIsLoading} searchTerm={\"Culture\"} />\n                    <Searchable searchValue={featuredResult.technique} setSearchResults={setSearchResults} setIsLoading={setIsLoading} searchTerm={\"Technique\"} />\n                    <Searchable searchValue={featuredResult.medium} setSearchResults={setSearchResults} setIsLoading={setIsLoading} searchTerm={\"Medium\"} />\n                    {featuredResult.people.map((person) => {\n                        return (<Searchable searchValue={person.displayname} setSearchResults={setSearchResults} setIsLoading={setIsLoading} searchTerm={\"People\"} />)\n                    })}\n                    <Fragment>\n                        <span className=\"title\">Dimensions</span>\n                        <span className=\"content\">{featuredResult.dimensions}</span>\n                    </Fragment>\n                    <Fragment>\n                        <span className=\"title\">Department</span>\n                        <span className=\"content\">{featuredResult.department}</span>\n                    </Fragment>\n                    <Fragment>\n                        <span className=\"title\">Division</span>\n                        <span className=\"content\">{featuredResult.division}</span>\n                    </Fragment>\n                    <Fragment>\n                        <span className=\"title\">Contact</span>\n                        <span className=\"content\">{featuredResult.contact}</span>\n                    </Fragment>\n                    <Fragment>\n                        <span className=\"title\">Credit</span>\n                        <span className=\"content\">{featuredResult.creditline}</span>\n                    </Fragment>\n                </section>\n                <section className=\"photos\">\n                    {featuredResult.images.map((image) => {\n                        console.log(image)\n                        return(\n                    <img src={image.baseimageurl} alt= {image.description}/>\n                    )})}\n                </section>\n            </div>\n        </main>\n    } else {\n        return <main></main>\n    }\n}\nexport default Feature;","import React from 'react';\n\n/**\n * Create and export a component called Loading which uses this static HTML template:\n * \n * <div id=\"loading\">\n *   <h2 className=\"message\">Searching...</h2>\n * </div>\n */\n\nconst Loading = () => {\n  return (\n      <div id='loading'>\n          <h2 className='message'> Searching...</h2>\n      </div>\n  )  \n}\n\n export default Loading;","import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n// These imports won't work until you fix ./components/index.js\nimport {\n  Feature,\n  Loading,\n  Preview,\n  Search,\n  Title\n} from './components';\nconst App = () => {\n  /**\n   * We are at the App level component, which is top-most. Any state which needs to be shared between immediate children should\n   * be made here, so create state pairs using useState() for:\n   *\n   * searchResults, setSearchResults (default should be this object:  {info: {}, records: []} )\n   * featuredResult, setFeaturedResult (default should be null)\n   * isLoading, setIsLoading (default should be false)\n   */\n  const [searchResults, setSearchResults] = useState({ info: {}, records: [] });\n  const [featuredResult, setFeaturedResult] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  return <div className=\"app\">\n    {/* <Title /> is static, doesn't need any props */}\n    <Title />\n    {/* <Search /> needs props for setIsLoading and setSearchResults (trigger <Loading /> on search start/end, and transfer results to preview) */}\n    <Search searchResults={searchResults} setIsLoading={setIsLoading} setSearchResults={setSearchResults} setFeaturedResult={setFeaturedResult} />\n    {/* <Preview /> needs props for searchResults, setIsLoading and setSearchResults (clicking prev/next buttons), and setFeaturedResult (clicking a preview) */}\n    <Preview searchResults={searchResults} setIsLoading={setIsLoading} setSearchResults={setSearchResults} setFeaturedResult={setFeaturedResult}/>\n    {/* <Feature /> needs props for featuredResult, as well as setIsLoading and setSearchResults (clicking on searchable properties) */}\n    <Feature featuredResult={featuredResult} setIsLoading={setIsLoading} setSearchResults={setSearchResults}/>\n    {/* <Loading /> is static, but should only render when isLoading is true */}\n    {isLoading ? <Loading /> : null}  {/* use a ternary and render null if isLoading is false */}\n  </div>\n}\n/**\n * Boostrap the <App /> component into the '#app' element in the DOM,\n * using ReactDOM.render();\n */\nReactDOM.render(<App />, document.getElementById('app'));\n"],"sourceRoot":""}